---
# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: 2025 The Linux Foundation

name: 'Sigul Build/Test üê≥'

# yamllint disable-line rule:truthy
on:
  workflow_dispatch:
    inputs:
      clear_cache:
        description: 'Clear all build caches'
        type: boolean
        default: false
        required: false

  push:
    branches: ['main']
  pull_request:
    branches: ['main']

concurrency:
  group: "${{ github.workflow }}-${{ github.ref }}"
  cancel-in-progress: true

permissions:
  contents: read
  packages: write
  actions: write  # Required for cache deletion when clear_cache is true

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}/sigul-sign-docker
  DOCKER_BUILDKIT: '1'
  BUILDKIT_PROGRESS: plain

jobs:
  ### Build Sigul Client Container ###
  build-containers:
    name: "Build: ${{ matrix.component }} (${{ matrix.platform }})"
    runs-on: ${{ matrix.runner }}
    permissions:
      contents: read
      actions: write  # Required for cache deletion when clear_cache is true
    timeout-minutes: 6
    env:
      GH_TOKEN: "${{ secrets.GITHUB_TOKEN }}"
    strategy:
      fail-fast: false
      matrix:
        # Use ubuntu-latest for AMD64 builds (x86_64 runners)
        # Use ubuntu-24.04-arm for ARM64 builds (native ARM64 runners)
        # This avoids QEMU emulation which can cause timeouts and failures
        include:
          - component: 'client'
            platform: 'linux/amd64'
            runner: ubuntu-24.04
          - component: 'client'
            platform: 'linux/arm64'
            runner: ubuntu-24.04-arm
          - component: 'server'
            platform: 'linux/amd64'
            runner: ubuntu-24.04
          - component: 'server'
            platform: 'linux/arm64'
            runner: ubuntu-24.04-arm
          - component: 'bridge'
            platform: 'linux/amd64'
            runner: ubuntu-24.04
          - component: 'bridge'
            platform: 'linux/arm64'
            runner: ubuntu-24.04-arm
    outputs:
      client-amd64-digest: ${{ steps.build-client-amd64.outputs.digest }}
      client-arm64-digest: ${{ steps.build-client-arm64.outputs.digest }}
      server-amd64-digest: ${{ steps.build-server-amd64.outputs.digest }}
      server-arm64-digest: ${{ steps.build-server-arm64.outputs.digest }}
      bridge-amd64-digest: ${{ steps.build-bridge-amd64.outputs.digest }}
      bridge-arm64-digest: ${{ steps.build-bridge-arm64.outputs.digest }}
      client-image-tag: ${{ steps.meta.outputs.tags }}
    steps:
      # Harden the runner used by this workflow
      # yamllint disable-line rule:line-length
      - uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: 'audit'

      - name: 'Checkout repository'
        # yamllint disable-line rule:line-length
        uses: actions/checkout@1af3b93b6815bc44a9784bd300feb67ff0d1eeb3  # v6.0.0

      - name: 'Set up Docker Buildx'
        # yamllint disable-line rule:line-length
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435  # v3.11.1

      - name: 'Clear build caches if requested'
        if: ${{ github.event.inputs.clear_cache == true }}
        run: |
          echo "üßπ Clearing all build caches..."

          # Clear Docker BuildKit cache
          docker buildx prune --all --force || true

          # Clear GitHub Actions cache
          gh cache list | cut -f1 | xargs -I {} gh cache delete {} || true

          echo "‚úÖ All caches cleared"

      - name: 'Extract platform identifier'
        id: platform
        shell: bash
        run: |
          platform_id="${{ matrix.platform }}"
          platform_id="${platform_id//\//-}"
          echo "id=${platform_id}" >> "$GITHUB_OUTPUT"
          echo "Platform ID: ${platform_id}"

      - name: 'Extract metadata for tagging (client only)'
        id: meta
        if: matrix.component == 'client'
        # yamllint disable-line rule:line-length
        uses: docker/metadata-action@318604b99e75e41977312d83839a89be02ca4893  # v5.9.0
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          # yamllint disable rule:line-length
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix=main-,enable=${{ github.ref == 'refs/heads/main' }}
            type=sha,prefix=pr-,enable=${{ github.event_name == 'pull_request' }}
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}

      - name: "Build ${{ matrix.component }} container for ${{ matrix.platform }}"
        # yamllint disable-line rule:line-length
        uses: docker/build-push-action@263435318d21b8e681c14492fe198d362a7d2c83  # v6.18.0
        id: docker-build
        with:
          context: .
          file: Dockerfile.${{ matrix.component }}
          platforms: ${{ matrix.runner == 'ubuntu-24.04-arm' && '' || matrix.platform }}
          tags: |
            ${{ matrix.component }}:${{ steps.platform.outputs.id }}
            ${{ matrix.component == 'client' && steps.meta.outputs.tags || '' }}
          outputs: |
            type=docker,dest=/tmp/${{ matrix.component }}-${{ steps.platform.outputs.id }}.tar
          push: false
          cache-from: ${{ github.event.inputs.clear_cache == true && 'type=registry,ref=localhost/null' || format('type=gha,scope={0}-{1}-{2}', matrix.component, matrix.platform, matrix.runner) }}
          cache-to: type=gha,mode=max,scope=${{ matrix.component }}-${{ matrix.platform }}-${{ matrix.runner }}

      - name: 'Set build outputs for client amd64'
        id: build-client-amd64
        if: matrix.component == 'client' && matrix.platform == 'linux/amd64'
        run: |
          echo "digest=${{ steps.docker-build.outputs.digest }}" >> "$GITHUB_OUTPUT"

      - name: 'Set build outputs for client arm64'
        id: build-client-arm64
        if: matrix.component == 'client' && matrix.platform == 'linux/arm64'
        run: |
          echo "digest=${{ steps.docker-build.outputs.digest }}" >> "$GITHUB_OUTPUT"

      - name: 'Set build outputs for server amd64'
        id: build-server-amd64
        if: matrix.component == 'server' && matrix.platform == 'linux/amd64'
        run: |
          echo "digest=${{ steps.docker-build.outputs.digest }}" >> "$GITHUB_OUTPUT"

      - name: 'Set build outputs for server arm64'
        id: build-server-arm64
        if: matrix.component == 'server' && matrix.platform == 'linux/arm64'
        run: |
          echo "digest=${{ steps.docker-build.outputs.digest }}" >> "$GITHUB_OUTPUT"

      - name: 'Set build outputs for bridge amd64'
        id: build-bridge-amd64
        if: matrix.component == 'bridge' && matrix.platform == 'linux/amd64'
        run: |
          echo "digest=${{ steps.docker-build.outputs.digest }}" >> "$GITHUB_OUTPUT"

      - name: 'Set build outputs for bridge arm64'
        id: build-bridge-arm64
        if: matrix.component == 'bridge' && matrix.platform == 'linux/arm64'
        run: |
          echo "digest=${{ steps.docker-build.outputs.digest }}" >> "$GITHUB_OUTPUT"

      - name: 'Upload ${{ matrix.component }} image as artifact'
        # yamllint disable-line rule:line-length
        uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4  # v5.0.0
        if: success()
        with:
          name: ${{ matrix.component }}-${{ steps.platform.outputs.id }}-image
          path: /tmp/${{ matrix.component }}-${{ steps.platform.outputs.id }}.tar
          retention-days: 7



  publish-ghcr:
    name: 'Publish to GHCR'
    runs-on: 'ubuntu-latest'
    permissions:
      contents: read
      packages: write
    timeout-minutes: 3
    needs: [build-containers]
    # Temporarily disable while debugging integration tests/stack
    if: false
    # if: github.event_name != 'pull_request'
    steps:
      # Harden the runner used by this workflow
      # yamllint disable-line rule:line-length
      - uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: 'audit'

      - name: 'Checkout repository'
        # yamllint disable-line rule:line-length
        uses: actions/checkout@1af3b93b6815bc44a9784bd300feb67ff0d1eeb3  # v6.0.0

      - name: 'Set up Docker Buildx'
        # yamllint disable-line rule:line-length
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435  # v3.11.1

      - name: 'Log in to GitHub Container Registry'
        # yamllint disable-line rule:line-length
        uses: docker/login-action@5e57cd118135c172c3672efd75eb46360885c0ef  # v3.6.0
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: 'Download AMD64 Docker image artifact'
        # yamllint disable-line rule:line-length
        uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53  # v6.0.0
        continue-on-error: true
        id: download-amd64
        with:
          name: client-linux-amd64-image
          path: /tmp

      - name: 'Download ARM64 Docker image artifact'
        # yamllint disable-line rule:line-length
        uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53  # v6.0.0
        continue-on-error: true
        id: download-arm64
        with:
          name: client-linux-arm64-image
          path: /tmp

      - name: 'Load and prepare Docker images'
        shell: bash
        run: |
          set -e

          # Load and tag images
          platforms_built=()

          if [ "${{ steps.download-amd64.outcome }}" = "success" ] && [ -f "/tmp/client-linux-amd64.tar" ]; then
            echo "Loading AMD64 image..."
            docker load --input /tmp/client-linux-amd64.tar

            # Get the loaded image name and retag it for pushing
            amd64_image=$(docker images --format "table {{.Repository}}:{{.Tag}}" | grep "client:linux-amd64" | head -1)
            if [ -n "$amd64_image" ]; then
              platforms_built+=("linux/amd64")
              echo "AMD64 image loaded: $amd64_image"
            fi
          fi

          if [ "${{ steps.download-arm64.outcome }}" = "success" ] && [ -f "/tmp/client-linux-arm64.tar" ]; then
            echo "Loading ARM64 image..."
            docker load --input /tmp/client-linux-arm64.tar

            # Get the loaded image name and retag it for pushing
            arm64_image=$(docker images --format "table {{.Repository}}:{{.Tag}}" | grep "client:linux-arm64" | head -1)
            if [ -n "$arm64_image" ]; then
              platforms_built+=("linux/arm64")
              echo "ARM64 image loaded: $arm64_image"
            fi
          fi

          echo "Platforms available: ${platforms_built[*]}"

          if [ ${#platforms_built[@]} -eq 0 ]; then
            echo "‚ùå No platforms were successfully built and downloaded"
            exit 1
          fi

      - name: 'Extract metadata for final push'
        id: meta
        # yamllint disable-line rule:line-length
        uses: docker/metadata-action@318604b99e75e41977312d83839a89be02ca4893  # v5.9.0
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          # yamllint disable rule:line-length
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=sha,prefix=main-,enable=${{ github.ref == 'refs/heads/main' }}
            type=sha,prefix=pr-,enable=${{ github.event_name == 'pull_request' }}
            type=raw,value=latest,enable=${{ github.ref == 'refs/heads/main' }}

      # yamllint enable rule:line-length
      - name: 'Push pre-built images to registry'
        shell: bash
        run: |
          set -e

          # Push individual platform images first
          if [ "${{ steps.download-amd64.outcome }}" = "success" ] && \
             [ -f "/tmp/client-linux-amd64.tar" ]; then
            echo "Pushing AMD64 image..."
            # shellcheck disable=SC2043
            readarray -t tags <<< "${{ steps.meta.outputs.tags }}"
            for tag in "${tags[@]}"; do
              docker tag client:linux-amd64 "${tag}-amd64"
              docker push "${tag}-amd64"
            done
          fi

          if [ "${{ steps.download-arm64.outcome }}" = "success" ] && \
             [ -f "/tmp/client-linux-arm64.tar" ]; then
            echo "Pushing ARM64 image..."
            # shellcheck disable=SC2043
            readarray -t tags <<< "${{ steps.meta.outputs.tags }}"
            for tag in "${tags[@]}"; do
              docker tag client:linux-arm64 "${tag}-arm64"
              docker push "${tag}-arm64"
            done
          fi

          # Create and push multi-platform manifests
          # shellcheck disable=SC2043
          readarray -t tags <<< "${{ steps.meta.outputs.tags }}"
          for tag in "${tags[@]}"; do
            echo "Creating manifest for: $tag"

            manifest_args=()
            if [ "${{ steps.download-amd64.outcome }}" = "success" ]; then
              manifest_args+=("${tag}-amd64")
            fi
            if [ "${{ steps.download-arm64.outcome }}" = "success" ]; then
              manifest_args+=("${tag}-arm64")
            fi

            if [ ${#manifest_args[@]} -gt 0 ]; then
              docker manifest create "$tag" "${manifest_args[@]}"

              # Annotate platform-specific images
              if [ "${{ steps.download-amd64.outcome }}" = "success" ]; then
                docker manifest annotate "$tag" "${tag}-amd64" \
                  --arch amd64 --os linux
              fi
              if [ "${{ steps.download-arm64.outcome }}" = "success" ]; then
                docker manifest annotate "$tag" "${tag}-arm64" \
                  --arch arm64 --os linux
              fi

              docker manifest push "$tag"
              echo "‚úÖ Multi-platform manifest pushed: $tag"
            fi
          done

      - name: 'Verify published images'
        shell: bash
        run: |
          echo "=== Verifying published multi-platform images ==="
          # shellcheck disable=SC2043
          readarray -t tags <<< "${{ steps.meta.outputs.tags }}"
          for tag in "${tags[@]}"; do
            echo "Inspecting manifest for: ${tag}"
            docker manifest inspect "${tag}" || echo "Failed to inspect ${tag}"

            # Test pulling and running the image
            echo "Testing image: ${tag}"
            if docker pull "${tag}" 2>/dev/null; then
              docker run --rm "${tag}" sigul --version
              echo "‚úÖ Image verification passed for ${tag}"
            else
              echo "‚ö†Ô∏è Could not pull ${tag} for verification"
            fi
          done

  stack-deploy-test:
    name: 'Stack Deployment Test: ${{ matrix.platform }}'
    runs-on: ${{ matrix.runner }}
    permissions:
      contents: read
    timeout-minutes: 6
    needs: build-containers
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: linux/amd64
            runner: ubuntu-latest
          - platform: linux/arm64
            runner: ubuntu-24.04-arm
    outputs:
      server-container: ${{ steps.deploy.outputs.server-container }}
      bridge-container: ${{ steps.deploy.outputs.bridge-container }}
      server-ip: ${{ steps.deploy.outputs.server-ip }}
      bridge-ip: ${{ steps.deploy.outputs.bridge-ip }}
      # yamllint disable-line rule:line-length
      client-image: client-${{ steps.runner-arch.outputs.platform-id }}-image:test
      runner-platform: ${{ steps.runner-arch.outputs.platform-id }}
      docker-platform: ${{ steps.runner-arch.outputs.docker-platform }}
    steps:
      # Harden the runner used by this workflow
      # yamllint disable-line rule:line-length
      - uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: 'audit'

      - name: 'Checkout repository'
        # yamllint disable-line rule:line-length
        uses: actions/checkout@1af3b93b6815bc44a9784bd300feb67ff0d1eeb3 # v6.0.0

      - name: 'Set up Docker Buildx'
        # yamllint disable-line rule:line-length
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435  # v3.11.1

      - name: 'Detect runner architecture'
        id: runner-arch
        shell: bash
        run: |
          # Detect the runner architecture
          ARCH=$(uname -m)
          case $ARCH in
            x86_64)
              PLATFORM_ID="linux-amd64"
              DOCKER_PLATFORM="linux/amd64"
              ;;
            aarch64|arm64)
              PLATFORM_ID="linux-arm64"
              DOCKER_PLATFORM="linux/arm64"
              ;;
            *)
              echo "‚ùå Unsupported architecture: $ARCH"
              exit 1
              ;;
          esac
          echo "platform-id=${PLATFORM_ID}" >> "$GITHUB_OUTPUT"
          echo "docker-platform=${DOCKER_PLATFORM}" >> "$GITHUB_OUTPUT"
          echo "üìç Detected runner architecture: $ARCH -> $PLATFORM_ID"

      - name: 'Download Sigul Client image artifact'
        # yamllint disable-line rule:line-length
        uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53  # v6.0.0
        with:
          name: 'client-${{ steps.runner-arch.outputs.platform-id }}-image'
          path: /tmp

      - name: 'Download Sigul Server image artifact'
        # yamllint disable-line rule:line-length
        uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53  # v6.0.0
        with:
          name: >-
            server-${{ steps.runner-arch.outputs.platform-id }}-image
          path: /tmp

      - name: 'Download Sigul Bridge image artifact'
        # yamllint disable-line rule:line-length
        uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53  # v6.0.0
        with:
          name: >-
            bridge-${{ steps.runner-arch.outputs.platform-id }}-image
          path: /tmp

      - name: 'Showing downloaded docker images'
        shell: bash
        run: |
          # Showing downloaded docker images
          echo "üîç Showing downloaded docker images"
          echo "==================================="
          ls -la /tmp/*.tar
          echo "==================================="

      - name: 'Loading/tagging container images'
        shell: bash
        run: |
          # Loading/tagging container images
          PLATFORM_ID="${{ steps.runner-arch.outputs.platform-id }}"
          echo "üîß Loading/tagging ${PLATFORM_ID} container images"

          # Load sigul-client image
          CLIENT_IMAGE_FILE="/tmp/client-${PLATFORM_ID}.tar"
          if [ -f "${CLIENT_IMAGE_FILE}" ]; then
            echo "Loading Sigul client image for ${PLATFORM_ID}..."
            docker load --input "${CLIENT_IMAGE_FILE}"
            # Tag the loaded image appropriately
            docker tag "client:${PLATFORM_ID}" \
              "client-${PLATFORM_ID}-image:test"
            echo "‚úÖ Sigul client image loaded and tagged"
          else
            echo "‚ùå Sigul client image not found: ${CLIENT_IMAGE_FILE}"
            echo "Available files matching client pattern:"
            ls -la /tmp/client*.tar 2>/dev/null || \
              echo "No client .tar files found"
            exit 1
          fi

          # Load server image
          SERVER_IMAGE_FILE="/tmp/server-${PLATFORM_ID}.tar"
          if [ -f "${SERVER_IMAGE_FILE}" ]; then
            echo "Loading server image for ${PLATFORM_ID}..."
            docker load --input "${SERVER_IMAGE_FILE}"
            # Tag the loaded image appropriately
            docker tag "server:${PLATFORM_ID}" \
              "server-${PLATFORM_ID}-image:test"
            echo "‚úÖ Sigul server image loaded and tagged"
          else
            echo "‚ùå Sigul server image not found: ${SERVER_IMAGE_FILE}"
            echo "Available files matching server pattern:"
            ls -la /tmp/server*.tar 2>/dev/null || \
              echo "No server .tar files found"
            exit 1
          fi

          # Load bridge image
          BRIDGE_IMAGE_FILE="/tmp/bridge-${PLATFORM_ID}.tar"
          if [ -f "${BRIDGE_IMAGE_FILE}" ]; then
            echo "Loading bridge image for ${PLATFORM_ID}..."
            docker load --input "${BRIDGE_IMAGE_FILE}"
            # Tag the loaded image appropriately
            docker tag "bridge:${PLATFORM_ID}" \
              "bridge-${PLATFORM_ID}-image:test"
            echo "‚úÖ Sigul bridge image loaded and tagged"
          else
            echo "‚ùå Sigul bridge image not found: ${BRIDGE_IMAGE_FILE}"
            echo "Available files matching bridge pattern:"
            ls -la /tmp/bridge*.tar 2>/dev/null || \
              echo "No bridge .tar files found"
            exit 1
          fi

          # Verify all images are loaded
          echo "üìã Successfully loaded Docker images:"
          docker images | grep -E "(client|server|bridge)" || \
            echo "No Sigul images found"
          echo ""
          echo "‚úÖ All Sigul images loaded successfully"

      - name: 'Set client image output'
        shell: bash
        # yamllint disable rule:line-length
        run: |
          echo "image=client-${{ steps.runner-arch.outputs.platform-id }}-image:test" >> "$GITHUB_OUTPUT"

      # yamllint enable rule:line-length
      - name: 'Deploy Sigul infrastructure'
        id: deploy
        shell: bash
        env:
          SIGUL_PLATFORM_ID: ${{ steps.runner-arch.outputs.platform-id }}
          DOCKER_PLATFORM: ${{ steps.runner-arch.outputs.docker-platform }}
        run: |
          PLATFORM="${SIGUL_PLATFORM_ID}"
          echo "üöÄ Deploying Sigul infrastructure for platform: ${PLATFORM}"
          echo "üì¶ Sigul containers will be for platform: ${DOCKER_PLATFORM}"

          # Export platform info for the deployment script
          export SIGUL_RUNNER_PLATFORM="${SIGUL_PLATFORM_ID}"
          export SIGUL_DOCKER_PLATFORM="${DOCKER_PLATFORM}"

          # Use the unified deployment script
          DEPLOY_SCRIPT="scripts/deploy-sigul-infrastructure.sh"
          echo "Using deployment script: ${DEPLOY_SCRIPT}"

          chmod +x "${DEPLOY_SCRIPT}"
          "./${DEPLOY_SCRIPT}" --verbose

          # Set outputs for subsequent jobs
          {
            echo "server-container=sigul-server"
            echo "bridge-container=sigul-bridge"
            echo "runner-platform=${SIGUL_PLATFORM_ID}"
            echo "docker-platform=${DOCKER_PLATFORM}"
          } >> "$GITHUB_OUTPUT"

          echo "‚úÖ Sigul infrastructure deployed for ${PLATFORM}"

      - name: 'Upload PKI and config artifacts'
        # yamllint disable-line rule:line-length
        uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4  # v5.0.0
        with:
          name: >-
            sigul-infrastructure-config-${{
              steps.runner-arch.outputs.platform-id
            }}
          path: |
            pki/
            configs/
            test-artifacts/
          retention-days: 1

      - name: 'Collect container logs and diagnostics'
        if: always()
        shell: bash
        run: |
          echo "üìã Collecting container logs and diagnostic information..."

          # Stream container logs immediately to workflow output for visibility
          echo "::group::Container Log Streaming (Immediate Visibility)"
          for container in sigul-server sigul-bridge; do
            if docker ps -a --format "{{.Names}}" | \
              grep -q "^${container}$"; then
              echo "=== ${container} logs (last 100 lines) ==="
              docker logs --tail 100 "${container}" 2>&1 || \
                echo "Unable to fetch logs from ${container}"
              echo ""
              echo "=== ${container} container status ==="
              docker container inspect "${container}" --format \
                'Status: {{.State.Status}} (Exit: {{.State.ExitCode}})' \
                2>/dev/null || echo "Cannot inspect ${container}"
              echo ""
            else
              echo "Container not found: ${container}"
            fi
          done
          echo "::endgroup::"

          # Create diagnostics directory for artifacts
          mkdir -p diagnostics

          # Collect full container logs for artifacts
          for container in sigul-server sigul-bridge; do
            if docker ps -a --format "{{.Names}}" | \
               grep -q "^${container}$"; then
              echo "Collecting full logs for container: ${container}"
              docker logs "${container}" > \
                "diagnostics/${container}.log" 2>&1 || true
              docker inspect "${container}" > \
                "diagnostics/${container}.inspect.json" 2>/dev/null || true
            else
              echo "Container not found: ${container}"
            fi
          done

          # Collect volume diagnostics using FHS-compliant paths
          if docker ps -a --format "{{.Names}}" | grep -q "^sigul-bridge$"; then
            echo "Collecting bridge volume diagnostics..."
            bridge_nss_volume=$(
              docker inspect sigul-bridge --format \
                '{{range .Mounts}}' \
                '{{if eq .Destination "/etc/pki/sigul/bridge"}}' \
                '{{.Name}}{{end}}{{end}}' 2>/dev/null || echo ""
            )
            if [[ -n "$bridge_nss_volume" ]]; then
              echo "Bridge NSS volume name: $bridge_nss_volume"
              docker run --rm -v "${bridge_nss_volume}":/nss-data \
                alpine:3.19 sh -c '
                echo "=== Bridge NSS Volume Directory Structure ===" \
                  > /tmp/bridge-volume.txt
                find /nss-data -type f -exec ls -la {} \; >> \
                  /tmp/bridge-volume.txt 2>&1 || true
                echo "=== Bridge NSS Database Files ===" \
                  >> /tmp/bridge-volume.txt
                ls -la /nss-data/*.db /nss-data/pkcs11.txt >> \
                  /tmp/bridge-volume.txt 2>&1 || true
                cat /tmp/bridge-volume.txt
              ' > diagnostics/bridge-volume.txt 2>&1 || true
            else
              echo "Could not determine bridge NSS volume name" > \
                diagnostics/bridge-volume.txt
            fi
          fi

          # Collect system state
          docker ps -a > diagnostics/docker-containers.txt 2>&1 || true
          docker volume ls > diagnostics/docker-volumes.txt 2>&1 || true
          docker network ls > diagnostics/docker-networks.txt 2>&1 || true

          echo "‚úÖ Diagnostics collection completed"

      - name: 'Upload container logs and diagnostics'
        # yamllint disable-line rule:line-length
        uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4  # v5.0.0
        if: always()
        with:
          name: >-
            sigul-container-diagnostics-${{
              steps.runner-arch.outputs.platform-id
            }}
          path: |
            diagnostics/
          retention-days: 3

  ### Functional Tests ###
  functional-tests:
    name: 'Functional Tests: ${{ matrix.platform }}'
    runs-on: ${{ matrix.runner }}
    permissions:
      contents: read
    timeout-minutes: 8
    needs: build-containers
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: linux/amd64
            runner: ubuntu-latest
          - platform: linux/arm64
            runner: ubuntu-24.04-arm
    steps:
      # Harden the runner used by this workflow
      # yamllint disable-line rule:line-length
      - uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: 'audit'

      - name: 'Checkout repository'
        # yamllint disable-line rule:line-length
        uses: actions/checkout@1af3b93b6815bc44a9784bd300feb67ff0d1eeb3 # v6.0.0

      - name: 'Set up Docker Buildx'
        # yamllint disable-line rule:line-length
        uses: docker/setup-buildx-action@e468171a9de216ec08956ac3ada2f0791b6bd435  # v3.11.1

      - name: 'Detect runner architecture'
        id: runner-arch
        shell: bash
        run: |
          # Detect the runner architecture
          ARCH=$(uname -m)
          case $ARCH in
            x86_64)
              PLATFORM_ID="linux-amd64"
              DOCKER_PLATFORM="linux/amd64"
              ;;
            aarch64|arm64)
              PLATFORM_ID="linux-arm64"
              DOCKER_PLATFORM="linux/arm64"
              ;;
            *)
              echo "‚ùå Unsupported architecture: $ARCH"
              exit 1
              ;;
          esac
          echo "platform-id=${PLATFORM_ID}" >> "$GITHUB_OUTPUT"
          echo "docker-platform=${DOCKER_PLATFORM}" >> "$GITHUB_OUTPUT"
          echo "üìç Detected runner architecture: $ARCH -> $PLATFORM_ID"

      - name: 'Download Sigul Client image artifact'
        # yamllint disable-line rule:line-length
        uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53  # v6.0.0
        with:
          name: 'client-${{ steps.runner-arch.outputs.platform-id }}-image'
          path: /tmp

      - name: 'Download Sigul Server image artifact'
        # yamllint disable-line rule:line-length
        uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53  # v6.0.0
        with:
          name: >-
            server-${{ steps.runner-arch.outputs.platform-id }}-image
          path: /tmp

      - name: 'Download Sigul Bridge image artifact'
        # yamllint disable-line rule:line-length
        uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53  # v6.0.0
        with:
          name: >-
            bridge-${{ steps.runner-arch.outputs.platform-id }}-image
          path: /tmp

      - name: 'Load and tag container images'
        shell: bash
        run: |
          # Loading/tagging container images
          PLATFORM_ID="${{ steps.runner-arch.outputs.platform-id }}"
          echo "üîß Loading/tagging ${PLATFORM_ID} container images for" \
            "functional tests"

          # Load sigul-client image
          CLIENT_IMAGE_FILE="/tmp/client-${PLATFORM_ID}.tar"
          if [ -f "${CLIENT_IMAGE_FILE}" ]; then
            echo "Loading Sigul client image for ${PLATFORM_ID}..."
            docker load --input "${CLIENT_IMAGE_FILE}"
            docker tag "client:${PLATFORM_ID}" \
              "client-${PLATFORM_ID}-image:test"
            echo "‚úÖ Sigul client image loaded and tagged"
          else
            echo "‚ùå Sigul client image not found: ${CLIENT_IMAGE_FILE}"
            exit 1
          fi

          # Load server image
          SERVER_IMAGE_FILE="/tmp/server-${PLATFORM_ID}.tar"
          if [ -f "${SERVER_IMAGE_FILE}" ]; then
            echo "Loading server image for ${PLATFORM_ID}..."
            docker load --input "${SERVER_IMAGE_FILE}"
            docker tag "server:${PLATFORM_ID}" \
              "server-${PLATFORM_ID}-image:test"
            echo "‚úÖ Sigul server image loaded and tagged"
          else
            echo "‚ùå Sigul server image not found: ${SERVER_IMAGE_FILE}"
            exit 1
          fi

          # Load bridge image
          BRIDGE_IMAGE_FILE="/tmp/bridge-${PLATFORM_ID}.tar"
          if [ -f "${BRIDGE_IMAGE_FILE}" ]; then
            echo "Loading bridge image for ${PLATFORM_ID}..."
            docker load --input "${BRIDGE_IMAGE_FILE}"
            docker tag "bridge:${PLATFORM_ID}" \
              "bridge-${PLATFORM_ID}-image:test"
            echo "‚úÖ Sigul bridge image loaded and tagged"
          else
            echo "‚ùå Sigul bridge image not found: ${BRIDGE_IMAGE_FILE}"
            exit 1
          fi

          echo "‚úÖ All Sigul images loaded successfully for functional tests"

      - name: 'Deploy fresh Sigul infrastructure for functional tests'
        shell: bash
        env:
          SIGUL_PLATFORM_ID: ${{ steps.runner-arch.outputs.platform-id }}
          DOCKER_PLATFORM: ${{ steps.runner-arch.outputs.docker-platform }}
        run: |
          PLATFORM="${SIGUL_PLATFORM_ID}"
          echo "üöÄ Deploying fresh Sigul infrastructure for functional tests"
          echo "üì¶ Platform: ${PLATFORM} (${DOCKER_PLATFORM})"

          # Export platform info for the deployment script
          export SIGUL_RUNNER_PLATFORM="${SIGUL_PLATFORM_ID}"
          export SIGUL_DOCKER_PLATFORM="${DOCKER_PLATFORM}"

          # Use the unified deployment script to deploy fresh stack
          DEPLOY_SCRIPT="scripts/deploy-sigul-infrastructure.sh"
          chmod +x "${DEPLOY_SCRIPT}"
          "./${DEPLOY_SCRIPT}" --verbose

          echo "‚úÖ Fresh Sigul infrastructure deployed for functional tests"

      - name: 'Validate NSS certificates in containers'
        shell: bash
        run: |
          echo 'üîç Validating NSS certificates inside containers...'

          # Debug: Show all running containers
          echo "üìã Current container status:"
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"

          # Check that containers are running and healthy
          BRIDGE_STATUS=$(docker ps --filter "name=sigul-bridge" \
            --format "{{.Status}}" || echo "not found")
          SERVER_STATUS=$(docker ps --filter "name=sigul-server" \
            --format "{{.Status}}" || echo "not found")

          echo "üîç Container status check:"
          echo "  Bridge: $BRIDGE_STATUS"
          echo "  Server: $SERVER_STATUS"

          if ! docker ps --format "{{.Names}}" | grep -q "^sigul-bridge$"; then
            echo "‚ùå sigul-bridge container not running (status: $BRIDGE_STATUS)"
            echo "üìã All containers:"
            docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Image}}"
            echo "üìã Bridge container logs:"
            docker logs sigul-bridge 2>&1 | tail -20 || echo "No logs available"
            exit 1
          fi

          if ! docker ps --format "{{.Names}}" | grep -q "^sigul-server$"; then
            echo "‚ùå sigul-server container not running (status: $SERVER_STATUS)"
            echo "üìã All containers:"
            docker ps -a --format "table {{.Names}}\t{{.Status}}\t{{.Image}}"
            echo "üìã Server container logs:"
            docker logs sigul-server 2>&1 | tail -20 || echo "No logs available"
            exit 1
          fi

          # Validate NSS certificates inside the bridge container
          echo "üîç Validating bridge NSS certificates..."
          if docker exec -e NSS_DIR=/etc/pki/sigul sigul-bridge \
            /usr/local/bin/validate-nss.sh bridge; then
            echo "‚úÖ Bridge NSS validation passed"
          else
            echo "‚ùå Bridge NSS validation failed"
            exit 1
          fi

          # Validate NSS certificates inside the server container
          echo "üîç Validating server NSS certificates..."
          if docker exec -e NSS_DIR=/etc/pki/sigul sigul-server \
            /usr/local/bin/validate-nss.sh server; then
            echo "‚úÖ Server NSS validation passed"
          else
            echo "‚ùå Server NSS validation failed"
            exit 1
          fi

          echo "‚úÖ All NSS certificate validations passed"

      - name: 'Run integration tests'
        shell: bash
        env:
          SIGUL_CLIENT_IMAGE: >-
            client-${{ steps.runner-arch.outputs.platform-id }}-image:test
          SIGUL_SERVER_IMAGE: >-
            server-${{ steps.runner-arch.outputs.platform-id }}-image:test
          SIGUL_BRIDGE_IMAGE: >-
            bridge-${{ steps.runner-arch.outputs.platform-id }}-image:test
        run: |
          echo 'Running Sigul integration tests against fresh infrastructure...'
          chmod +x scripts/run-integration-tests.sh
          ./scripts/run-integration-tests.sh --verbose

      - name: 'Upload integration test artifacts'
        # yamllint disable-line rule:line-length
        uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4  # v5.0.0
        if: always()
        with:
          name: >-
            integration-test-results-${{
              steps.runner-arch.outputs.platform-id
            }}
          path: |
            test-artifacts/
            *.txt
            *.asc
            *.rpm
          retention-days: 7

      - name: 'Clean up functional test infrastructure'
        if: always()
        shell: bash
        run: |
          echo "üßπ Cleaning up functional test infrastructure..."

          # Stop and remove containers from functional tests
          containers_to_cleanup=(
            "sigul-server"
            "sigul-bridge"
            "sigul-client-integration"
          )
          for container in "${containers_to_cleanup[@]}"; do
            if docker ps -a --format "{{.Names}}" | \
               grep -q "^${container}$"; then
              echo "Stopping and removing ${container}..."
              docker stop "${container}" >/dev/null 2>&1 || true
              docker rm "${container}" >/dev/null 2>&1 || true
            fi
          done

          # Clean up networks if they exist
          docker network ls --filter "name=sigul" --format "{{.Name}}" | \
            xargs -r docker network rm >/dev/null 2>&1 || true

          # Clean up any test volumes
          docker volume ls --filter "name=sigul" --format "{{.Name}}" | \
            xargs -r docker volume rm >/dev/null 2>&1 || true

          echo "‚úÖ Functional test infrastructure cleanup completed"

  ### Cleanup Sigul Infrastructure ###
  cleanup-infrastructure:
    name: 'Cleanup Infrastructure'
    runs-on: 'ubuntu-latest'
    permissions:
      contents: read
    timeout-minutes: 2
    needs: [stack-deploy-test, functional-tests]
    if: always()
    steps:
      # Harden the runner used by this workflow
      # yamllint disable-line rule:line-length
      - uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: 'audit'

      - name: 'Cleanup any remaining containers'
        shell: bash
        run: |
          echo 'Performing final cleanup of any remaining containers...'

          # Clean up any containers that might still be running
          containers_to_cleanup=(
            "test-sigul-server"
            "test-sigul-bridge"
            "sigul-client-test"
          )

          for container in "${containers_to_cleanup[@]}"; do
            if docker ps -a --filter "name=${container}" \
              --format "{{.Names}}" | grep -q "^${container}$"; then
              echo "Cleaning up ${container}..."
              docker stop "${container}" || true
              docker rm "${container}" || true
            fi
          done

          # Clean up any volumes or networks if needed
          docker system prune -f --volumes || true

          echo '‚úÖ Infrastructure cleanup completed'

  ### Sigul Build Summary ###
  summary:
    name: 'Build Summary'
    runs-on: 'ubuntu-latest'
    needs: [
      build-containers,
      publish-ghcr,
      stack-deploy-test,
      functional-tests
    ]
    if: always()
    timeout-minutes: 1
    # yamllint disable rule:line-length
    steps:
      - name: 'Generate build summary'
        shell: bash
        run: |
          {
            echo "## Sigul Build Summary üê≥"
            echo ""

            echo "### Build Results"
            echo "| Platform | Build | Stack Deploy | Integration | Status |"
            echo "|----------|-------|--------------|-------------|--------|"

            # Note: In real implementation, check actual job statuses
            echo "| linux/amd64 | ${{ needs.build-containers.result }} |" \
              " ${{ needs.stack-deploy-test.result }} |" \
              " ${{ needs.functional-tests.result }} | Complete |"
            echo "| linux/arm64 | ${{ needs.build-containers.result }} |" \
              " ${{ needs.stack-deploy-test.result }} |" \
              " ${{ needs.functional-tests.result }} | Complete |"
            echo ""

            echo "### Stack Deployment Tests"
            echo "- **Status**: ${{ needs.stack-deploy-test.result }}"
            echo "- **Includes**: Stack deployment validation, infrastructure setup"
            echo ""
            echo "### Functional Tests"
            echo "- **Status**: ${{ needs.functional-tests.result }}"
            echo "- **Includes**: Integration testing against fresh infrastructure"
            echo ""

            echo "### GHCR Publishing"
            echo "- **Registry**: ${{ env.REGISTRY }}"
            echo "- **Image**: ${{ env.IMAGE_NAME }}"
            echo "- **Status**: ${{ needs.publish-ghcr.result }}"
            echo "- **Method**: Pre-built artifacts (no rebuild)"
            echo ""

            if [ "${{ needs.publish-ghcr.result }}" = "success" ]; then
              echo "‚úÖ **Optimization Success**: Images were published using " \
                "pre-built artifacts, avoiding duplicate builds!"
            elif [ "${{ needs.publish-ghcr.result }}" = "skipped" ]; then
              echo "‚è≠Ô∏è **Publishing Skipped**: " \
              "pull requests cannot publish containers."
            else
              echo "‚ùå **Publishing Failed**: Check the publish-ghcr job " \
                "logs for details."
            fi
          } >> "$GITHUB_STEP_SUMMARY"
