# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: 2025 The Linux Foundation

# Unified Dockerfile for sigul client using the new sigul-init.sh approach
FROM registry.access.redhat.com/ubi9/ubi-minimal:latest

LABEL maintainer="releng@linuxfoundation.org"
LABEL org.opencontainers.image.title="Sigul Client"
LABEL org.opencontainers.image.description="Unified Linux Foundation signing infrastructure client"
LABEL org.opencontainers.image.source="https://github.com/lfreleng-actions/sigul-sign-docker"

# Install package managers and required dependencies
RUN microdnf install -y dnf && \
    microdnf clean all

# Setup repositories using dedicated script for better reliability
COPY build-scripts/setup-repositories.sh /tmp/setup-repositories.sh
RUN chmod +x /tmp/setup-repositories.sh && \
    /tmp/setup-repositories.sh --test && \
    rm /tmp/setup-repositories.sh

# Install base dependencies for all architectures
# Note: nss-devel and nspr-devel removed - python-nss-ng installed from PyPI (pre-built)
RUN dnf install -y --setopt=install_weak_deps=False --allowerasing \
        git which curl tar gzip xz \
        python3-devel python3-pip python3-koji python3-requests \
        python3-rpm python3-setuptools python3-cryptography python3-pexpect python3-gpg \
        gnupg2 koji-utils expect \
        make gcc autoconf automake libtool \
        procps-ng util-linux bind-utils \
        strace lsof \
        vim-minimal less findutils grep \
        curl wget rsync nmap-ncat \
        hostname iproute net-tools \
        sqlite nss-tools jq && \
    dnf clean all

# Copy patches for debugging (if they exist)
COPY patches/ /tmp/patches/

# Install Python 3.12 (Python 3.9 is EOL, python-nss-ng wheels require 3.10+)
COPY build-scripts/install-python.sh /tmp/install-python.sh
RUN chmod +x /tmp/install-python.sh && \
    /tmp/install-python.sh --version 3.12.8 --verify && \
    rm /tmp/install-python.sh

# Install python-nss-ng from PyPI (now compatible with Python 3.12)
ENV INSTALL_SOURCE=pypi
ENV PYTHON_NSS_NG_VERSION=v1.0.4
COPY build-scripts/install-python-nss.sh /tmp/install-python-nss.sh
RUN chmod +x /tmp/install-python-nss.sh && \
    /tmp/install-python-nss.sh --verify && \
    rm /tmp/install-python-nss.sh

# Copy and run sigul installation script
COPY build-scripts/install-sigul.sh /tmp/install-sigul.sh
RUN chmod +x /tmp/install-sigul.sh && \
    /tmp/install-sigul.sh --verify client && \
    rm /tmp/install-sigul.sh && \
    rm -rf /tmp/patches

# Create symlinks for NSS unsupported tools to make them accessible for testing
RUN ln -sf /usr/lib64/nss/unsupported-tools/tstclnt /usr/local/bin/tstclnt && \
    ln -sf /usr/lib64/nss/unsupported-tools/selfserv /usr/local/bin/selfserv && \
    ln -sf /usr/lib64/nss/unsupported-tools/strsclnt /usr/local/bin/strsclnt

# NSS-only initialization

# Copy NSS-only initialization script and validation tools
COPY scripts/sigul-init.sh /usr/local/bin/sigul-init.sh
COPY scripts/validate-nss.sh /usr/local/bin/validate-nss.sh
COPY scripts/lib/health.sh /usr/local/bin/health.sh
COPY scripts/sigul-config-nss-only.template /usr/local/bin/sigul-config-nss-only.template
COPY scripts/init-client-certs.sh /usr/local/bin/init-client-certs.sh
RUN chmod +x /usr/local/bin/sigul-init.sh /usr/local/bin/validate-nss.sh /usr/local/bin/health.sh /usr/local/bin/init-client-certs.sh

# NSS-only certificate management

# Copy shared PKI files for certificate generation (permissions set later after user creation)
COPY pki/ /workspace/pki/

# Copy signing entrypoint script for backward compatibility
COPY entrypoint.sh /usr/local/bin/entrypoint.sh
RUN chmod +x /usr/local/bin/entrypoint.sh

# Create sigul user and directories with consistent UID 1000 and GID 1000
# Handle both RPM-created users (x86_64) and manual creation (ARM64)
RUN if getent passwd sigul >/dev/null; then \
        # User exists, remove it and recreate with consistent UID/GID
        existing_uid=$(id -u sigul); \
        existing_gid=$(id -g sigul); \
        echo "Existing sigul user has UID $existing_uid, GID $existing_gid, recreating with UID/GID 1000"; \
        userdel sigul 2>/dev/null || true; \
        groupdel sigul 2>/dev/null || true; \
    fi && \
    # Create group first with GID 1000
    groupadd -g 1000 sigul && \
    # Create user with UID 1000 and GID 1000
    useradd -u 1000 -g 1000 -d /var/sigul -s /bin/bash sigul && \
    # Create unified sigul directory structure under /var/sigul
    mkdir -p /var/sigul && \
    chown sigul:sigul /var/sigul && \
    chmod 755 /var/sigul && \
    # Create /var/lib/sigul directory for NSS databases and GPG
    mkdir -p /var/lib/sigul && \
    chown sigul:sigul /var/lib/sigul && \
    chmod 755 /var/lib/sigul && \
    # Pre-create log file with correct ownership for sigul user
    touch /var/log/sigul_client.log && \
    chown sigul:sigul /var/log/sigul_client.log && \
    chmod 644 /var/log/sigul_client.log && \
    # Set proper permissions on PKI files after user creation
    # Only chmod files that exist (some are generated at runtime)
    if ls /workspace/pki/*.crt >/dev/null 2>&1; then chmod 644 /workspace/pki/*.crt; fi && \
    if ls /workspace/pki/*.conf >/dev/null 2>&1; then chmod 644 /workspace/pki/*.conf; fi && \
    if ls /workspace/pki/*.conf.template >/dev/null 2>&1; then chmod 644 /workspace/pki/*.conf.template; fi && \
    if ls /workspace/pki/*-key.pem >/dev/null 2>&1; then chmod 644 /workspace/pki/*-key.pem; fi && \
    if ls /workspace/pki/*.sh >/dev/null 2>&1; then chmod +x /workspace/pki/*.sh; fi && \
    chown -R sigul:sigul /workspace/pki/

# Create a wrapper script that can handle both initialization and signing
RUN cat > /usr/local/bin/client-wrapper.sh << 'EOF'
#!/bin/bash
# Unified client wrapper script for sigul user (UID/GID 1000)
# Handles both sigul initialization and signing operations

set -euo pipefail

log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] CLIENT-WRAPPER: $1" >&2
}

# Ensure we're running as the sigul user consistently
if [[ "$(id -u)" != "1000" ]]; then
    log "Warning: Running as UID $(id -u) instead of expected UID 1000 (sigul user)"
fi

# Check if this is a signing operation (legacy entrypoint.sh behavior)
if [[ -n "${SIGN_TYPE:-}" || -n "${SIGN_OBJECT:-}" ]]; then
    log "Detected signing operation - using entrypoint.sh"
    exec /usr/local/bin/entrypoint.sh "$@"
fi

# Check if this is sigul client initialization
if [[ "${1:-}" == "--role" && "${2:-}" == "client" ]] || [[ "${SIGUL_ROLE:-}" == "client" ]]; then
    log "Detected client initialization"
    exec /usr/local/bin/sigul-init.sh "$@"
fi

# If specific command provided, run it directly
if [[ $# -gt 0 && "${1:-}" != "--role" ]]; then
    log "Running command directly: $*"
    exec "$@"
fi

# Default: run init for client setup
log "Default mode - initializing sigul client"
export SIGUL_ROLE=client
exec /usr/local/bin/sigul-init.sh --role client "$@"
EOF

# Make the wrapper script executable
RUN chmod +x /usr/local/bin/client-wrapper.sh

# Set working directory to unified structure
WORKDIR /var/sigul

# Switch to sigul user (same as server and bridge)
USER sigul

# Use the wrapper script as the default command
CMD ["/usr/local/bin/client-wrapper.sh"]

# Health check - NSS certificate validation (FHS-compliant path)
HEALTHCHECK --interval=30s --timeout=10s --start-period=30s --retries=3 \
    CMD certutil -d sql:/etc/pki/sigul/client -L -n sigul-ca >/dev/null 2>&1 && \
        certutil -d sql:/etc/pki/sigul/client -L -n sigul-client-cert >/dev/null 2>&1 || exit 1
